<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Email Header Analysis</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 20px;
        font-family: Helvetica, Arial, sans-serif;
        background: #f5f5f5;
        color: #333;
      }

      h1 {
        margin: 0 0 20px 0;
        font-size: 24px;
        font-weight: 500;
        color: #2c3e50;
      }

      .back-link {
        display: inline-block;
        margin-bottom: 15px;
        color: #3498db;
        text-decoration: none;
        font-size: 14px;
      }

      .back-link:hover {
        text-decoration: underline;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .panel {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .editor-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        align-items: start;
      }

      .editor-section {
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      .section-title {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 10px;
        color: #555;
      }

      textarea {
        width: 100%;
        min-height: 500px;
        padding: 12px;
        font-family: "Courier New", monospace;
        font-size: 16px;
        border: 2px solid #ddd;
        border-radius: 4px;
        resize: vertical;
        line-height: 1.5;
      }

      textarea:focus {
        outline: none;
        border-color: #3498db;
      }

      .output {
        width: 100%;
        min-height: 500px;
        height: 500px;
        padding: 12px;
        font-family: "Courier New", monospace;
        font-size: 16px;
        border: 2px solid #ddd;
        border-radius: 4px;
        background: #fafafa;
        overflow-y: auto;
        overflow-x: auto;
        line-height: 1.5;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        resize: vertical;
      }

      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }

      .actions {
        display: flex;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .btn {
        background: #fafbfc;
        color: #24292e;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        text-decoration: none;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }

      .btn:hover {
        background: #f3f4f6;
      }

      .btn.secondary {
        background: #fafbfc;
        color: #24292e;
        border: 1px solid rgba(27, 31, 35, 0.15);
      }

      .btn.secondary:hover {
        background: #f3f4f6;
      }

      input[type="file"] {
        display: none;
      }

      label.file-btn {
        background: #0366d6;
        color: #fff;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        text-decoration: none;
        display: inline-block;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }

      label.file-btn:hover {
        background: #0256c5;
      }

      .options {
        margin-top: 20px;
        padding: 15px;
        background: #f9f9f9;
        border-radius: 4px;
      }

      .option-group {
        margin-bottom: 10px;
      }

      .option-group:last-child {
        margin-bottom: 0;
      }

      .option-label {
        font-size: 14px;
        color: #555;
      }

      label.checkbox-label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 14px;
        color: #555;
      }

      label.checkbox-label input[type="checkbox"] {
        margin-right: 8px;
      }

      .legend {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 10px;
      }

      .info {
        font-size: 13px;
        color: #7f8c8d;
        margin-top: 10px;
      }

      .hl-common-header {
        color: #e74c3c;
        font-weight: 600;
      }

      .hl-other-header {
        color: #9b59b6;
        font-weight: 600;
      }

      .hl-x-header {
        color: #16a085;
        font-weight: 600;
      }

      .hl-ipv4 {
        background: #fff3cd;
        color: #856404;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .hl-ipv6 {
        background: #d1ecf1;
        color: #0c5460;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .hl-email {
        color: #3498db;
        text-decoration: underline;
      }

      .hl-url {
        color: #2980b9;
        text-decoration: underline;
      }

      @media (max-width: 968px) {
        .editor-container {
          flex-direction: column;
        }
      }

      .collapsible-section {
        margin-top: 20px;
        border: 1px solid #ddd;
        border-radius: 4px;
        overflow: hidden;
      }

      .collapsible-header {
        background: #0366d6;
        color: white;
        padding: 12px 15px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        font-size: 16px;
        font-weight: 600;
      }

      .collapsible-header:hover {
        background: #0256c5;
      }

      .collapsible-header::before {
        content: "▼";
        margin-right: 8px;
        font-size: 12px;
        transition: transform 0.2s;
      }

      .collapsible-header.collapsed::before {
        transform: rotate(-90deg);
      }

      .collapsible-content {
        max-height: 500px;
        transition: max-height 0.3s ease;
        overflow: hidden;
      }

      .collapsible-content.collapsed {
        max-height: 0;
      }

      .data-table {
        width: 100%;
        border-collapse: collapse;
        background: white;
      }

      .data-table th,
      .data-table td {
        padding: 10px 15px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
        font-size: 14px;
        word-wrap: break-word;
        word-break: break-word;
      }

      .data-table th {
        background: #f8f9fa;
        font-weight: 600;
        color: #333;
      }

      .data-table tr:last-child td {
        border-bottom: none;
      }

      .data-table tr:hover {
        background: #f5f5f5;
      }

      .data-table td:first-child {
        color: #0078d4;
        font-weight: 600;
      }

      .table-wrapper {
        overflow-x: auto;
        overflow-y: auto;
        max-height: 400px;
      }

      #otherHeadersTable {
        table-layout: fixed;
      }

      #otherHeadersTable th:first-child,
      #otherHeadersTable td:first-child {
        width: 50px;
      }

      #otherHeadersTable th:nth-child(2),
      #otherHeadersTable td:nth-child(2) {
        width: 150px;
      }

      #otherHeadersTable th:nth-child(3),
      #otherHeadersTable td:nth-child(3) {
        width: auto;
        white-space: normal;
      }

      .no-data {
        padding: 20px 15px;
        text-align: center;
        color: #999;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <a href="index.html" class="back-link">← Back to Tools</a>

      <h1>Email Header Analysis</h1>

      <div class="controls">
        <label for="fileInput" class="file-btn">Load from File</label>
        <input type="file" id="fileInput" accept=".eml,.msg,.txt" />
        <button class="btn secondary" id="clearBtn">Clear</button>
      </div>

      <div class="panel">
        <div class="editor-container">
          <div class="editor-section">
            <div class="section-title">Input (Plain Text)</div>
            <textarea
              id="input"
              placeholder="Paste your email headers here..."
            ></textarea>
          </div>

          <div class="editor-section">
            <div class="section-title">Output (Highlighted)</div>
            <div class="output" id="output"></div>
          </div>
        </div>

        <div class="options">
          <div class="option-group">
            <div class="option-label">Highlight Options:</div>
            <div class="legend">
              <label class="checkbox-label">
                <input type="checkbox" id="highlightCommon" checked />
                <span class="hl-common-header">Common Headers</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightOther" checked />
                <span class="hl-other-header">Other Headers</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightX" checked />
                <span class="hl-x-header">X-Headers</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightIPv4" checked />
                <span class="hl-ipv4">IPv4 Addresses</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightIPv6" checked />
                <span class="hl-ipv6">IPv6 Addresses</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightEmail" checked />
                <span class="hl-email">Email Addresses</span>
              </label>
              <label class="checkbox-label">
                <input type="checkbox" id="highlightURL" checked />
                <span class="hl-url">URLs</span>
              </label>
            </div>
          </div>
          <div class="info">
            This tool highlights email headers based on RFC specifications.
            Supports .eml, .msg, and plain text formats.
          </div>
        </div>

        <!-- Collapsible Tables Section -->
        <div
          class="collapsible-section"
          id="summarySection"
          style="display: none"
        >
          <div class="collapsible-header" id="summaryHeader">Summary</div>
          <div class="collapsible-content" id="summaryContent">
            <div class="table-wrapper">
              <table class="data-table" id="summaryTable">
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <div
          class="collapsible-section"
          id="receivedSection"
          style="display: none"
        >
          <div class="collapsible-header" id="receivedHeader">
            Received headers
          </div>
          <div class="collapsible-content" id="receivedContent">
            <div class="table-wrapper">
              <table class="data-table" id="receivedTable">
                <thead>
                  <tr>
                    <th>Hop</th>
                    <th>Submitting host</th>
                    <th>Receiving host</th>
                    <th>Time</th>
                    <th>Delay</th>
                    <th>Type</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <div
          class="collapsible-section"
          id="otherHeadersSection"
          style="display: none"
        >
          <div class="collapsible-header" id="otherHeadersHeader">
            Other headers
          </div>
          <div class="collapsible-content" id="otherHeadersContent">
            <div class="table-wrapper">
              <table class="data-table" id="otherHeadersTable">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>Header</th>
                    <th>Value</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      const input = document.getElementById("input");
      const output = document.getElementById("output");
      const fileInput = document.getElementById("fileInput");
      const clearBtn = document.getElementById("clearBtn");

      const highlightCommon = document.getElementById("highlightCommon");
      const highlightOther = document.getElementById("highlightOther");
      const highlightX = document.getElementById("highlightX");
      const highlightIPv4 = document.getElementById("highlightIPv4");
      const highlightIPv6 = document.getElementById("highlightIPv6");
      const highlightEmail = document.getElementById("highlightEmail");
      const highlightURL = document.getElementById("highlightURL");

      const commonHeaders = [
        "A-IM",
        "Accept",
        "Accept-Additions",
        "Accept-Charset",
        "Accept-Datetime",
        "Accept-Encoding",
        "Accept-Features",
        "Accept-Language",
        "Accept-Patch",
        "Accept-Ranges",
        "Age",
        "Allow",
        "ALPN",
        "Also-Control",
        "Alt-Svc",
        "Alt-Used",
        "Alternate-Recipient",
        "Alternates",
        "Apply-To-Redirect-Ref",
        "Approved",
        "Archive",
        "Archived-At",
        "Article-Names",
        "Article-Updates",
        "Authentication-Control",
        "Authentication-Info",
        "Authentication-Results",
        "Authorization",
        "Auto-Submitted",
        "Autoforwarded",
        "Autosubmitted",
        "Base",
        "Bcc",
        "Body",
        "C-Ext",
        "C-Man",
        "C-Opt",
        "C-PEP",
        "C-PEP-Info",
        "Cache-Control",
        "CalDAV-Timezones",
        "Cc",
        "Close",
        "Comments",
        "Connection",
        "Content-Alternative",
        "Content-Base",
        "Content-Description",
        "Content-Disposition",
        "Content-Duration",
        "Content-Encoding",
        "Content-features",
        "Content-ID",
        "Content-Identifier",
        "Content-Language",
        "Content-Length",
        "Content-Location",
        "Content-MD5",
        "Content-Range",
        "Content-Return",
        "Content-Script-Type",
        "Content-Style-Type",
        "Content-Transfer-Encoding",
        "Content-Type",
        "Content-Version",
        "Control",
        "Conversion",
        "Conversion-With-Loss",
        "Cookie",
        "Cookie2",
        "DASL",
        "DAV",
        "DL-Expansion-History",
        "Date",
        "Date-Received",
        "Default-Style",
        "Deferred-Delivery",
        "Delivery-Date",
        "Delta-Base",
        "Depth",
        "Derived-From",
        "Destination",
        "Differential-ID",
        "Digest",
        "Discarded-X400-IPMS-Extensions",
        "Discarded-X400-MTS-Extensions",
        "Disclose-Recipients",
        "Disposition-Notification-Options",
        "Disposition-Notification-To",
        "Distribution",
        "DKIM-Signature",
        "Downgraded-Bcc",
        "Downgraded-Cc",
        "Downgraded-Disposition-Notification-To",
        "Downgraded-Final-Recipient",
        "Downgraded-From",
        "Downgraded-In-Reply-To",
        "Downgraded-Mail-From",
        "Downgraded-Message-Id",
        "Downgraded-Original-Recipient",
        "Downgraded-Rcpt-To",
        "Downgraded-References",
        "Downgraded-Reply-To",
        "Downgraded-Resent-Bcc",
        "Downgraded-Resent-Cc",
        "Downgraded-Resent-From",
        "Downgraded-Resent-Reply-To",
        "Downgraded-Resent-Sender",
        "Downgraded-Resent-To",
        "Downgraded-Return-Path",
        "Downgraded-Sender",
        "Downgraded-To",
        "Encoding",
        "Encrypted",
        "ETag",
        "Expect",
        "Expires",
        "Expiry-Date",
        "Ext",
        "Followup-To",
        "Forwarded",
        "From",
        "Generate-Delivery-Report",
        "GetProfile",
        "Hobareg",
        "Host",
        "HTTP2-Settings",
        "IM",
        "If",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Range",
        "If-Schedule-Tag-Match",
        "If-Unmodified-Since",
        "Importance",
        "In-Reply-To",
        "Incomplete-Copy",
        "Injection-Date",
        "Injection-Info",
        "Keep-Alive",
        "Keywords",
        "Label",
        "Language",
        "Last-Modified",
        "Latest-Delivery-Time",
        "Lines",
        "Link",
        "List-Archive",
        "List-Help",
        "List-ID",
        "List-Owner",
        "List-Post",
        "List-Subscribe",
        "List-Unsubscribe",
        "List-Unsubscribe-Post",
        "Location",
        "Lock-Token",
        "Man",
        "Max-Forwards",
        "Memento-Datetime",
        "Message-Context",
        "Message-ID",
        "Message-Type",
        "Meter",
        "MIME-Version",
        "MMHS-Exempted-Address",
        "MMHS-Extended-Authorisation-Info",
        "MMHS-Subject-Indicator-Codes",
        "MMHS-Handling-Instructions",
        "MMHS-Message-Instructions",
        "MMHS-Codress-Message-Indicator",
        "MMHS-Originator-Reference",
        "MMHS-Primary-Precedence",
        "MMHS-Copy-Precedence",
        "MMHS-Message-Type",
        "MMHS-Other-Recipients-Indicator-To",
        "MMHS-Other-Recipients-Indicator-CC",
        "MMHS-Acp127-Message-Identifier",
        "MMHS-Originator-PLAD",
        "MT-Priority",
        "Negotiate",
        "Newsgroups",
        "NNTP-Posting-Date",
        "NNTP-Posting-Host",
        "Obsoletes",
        "Opt",
        "Optional-WWW-Authenticate",
        "Ordering-Type",
        "Organization",
        "Origin",
        "Original-Encoded-Information-Types",
        "Original-From",
        "Original-Message-ID",
        "Original-Recipient",
        "Original-Sender",
        "Originator-Return-Address",
        "Original-Subject",
        "Overwrite",
        "P3P",
        "Path",
        "PEP",
        "PICS-Label",
        "Pep-Info",
        "Position",
        "Posting-Version",
        "Pragma",
        "Prefer",
        "Preference-Applied",
        "Prevent-NonDelivery-Report",
        "Priority",
        "ProfileObject",
        "Protocol",
        "Protocol-Info",
        "Protocol-Query",
        "Protocol-Request",
        "Proxy-Authenticate",
        "Proxy-Authentication-Info",
        "Proxy-Authorization",
        "Proxy-Features",
        "Proxy-Instruction",
        "Public",
        "Public-Key-Pins",
        "Public-Key-Pins-Report-Only",
        "Range",
        "Received",
        "Received-SPF",
        "Redirect-Ref",
        "References",
        "Referer",
        "Relay-Version",
        "Reply-By",
        "Reply-To",
        "Require-Recipient-Valid-Since",
        "Resent-Bcc",
        "Resent-Cc",
        "Resent-Date",
        "Resent-From",
        "Resent-Message-ID",
        "Resent-Reply-To",
        "Resent-Sender",
        "Resent-To",
        "Retry-After",
        "Return-Path",
        "Safe",
        "Schedule-Reply",
        "Schedule-Tag",
        "Sec-WebSocket-Accept",
        "Sec-WebSocket-Extensions",
        "Sec-WebSocket-Key",
        "Sec-WebSocket-Protocol",
        "Sec-WebSocket-Version",
        "Security-Scheme",
        "See-Also",
        "Sender",
        "Sensitivity",
        "Server",
        "Set-Cookie",
        "Set-Cookie2",
        "SetProfile",
        "SLUG",
        "SoapAction",
        "Solicitation",
        "Status-URI",
        "Strict-Transport-Security",
        "Subject",
        "Summary",
        "Supersedes",
        "Surrogate-Capability",
        "Surrogate-Control",
        "TCN",
        "TE",
        "Timeout",
        "To",
        "Topic",
        "Trailer",
        "Transfer-Encoding",
        "TTL",
        "Urgency",
        "URI",
        "Upgrade",
        "User-Agent",
        "Variant-Vary",
        "Vary",
        "VBR-Info",
        "Via",
        "WWW-Authenticate",
        "Want-Digest",
        "Warning",
        "X400-Content-Identifier",
        "X400-Content-Return",
        "X400-Content-Type",
        "X400-MTS-Identifier",
        "X400-Originator",
        "X400-Received",
        "X400-Recipients",
        "X400-Trace",
        "X-Frame-Options",
        "Xref",
      ];

      const otherHeaders = [
        "Delivered-To",
        "Errors-To",
        "Precedence",
        "Thread-Index",
        "Thread-Topic",
      ];

      function escapeHtml(text) {
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#039;",
        };
        return text.replace(/[&<>"']/g, (m) => map[m]);
      }

      function highlightText(text) {
        if (!text) return "";

        let highlighted = escapeHtml(text);

        if (highlightIPv6.checked) {
          const ipv6Regex =
            /((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}))|:)))/g;
          highlighted = highlighted.replace(
            ipv6Regex,
            (match) => `<span class="hl-ipv6">${match}</span>`
          );
        }

        if (highlightIPv4.checked) {
          const ipv4Regex =
            /\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b/g;
          highlighted = highlighted.replace(
            ipv4Regex,
            (match) => `<span class="hl-ipv4">${match}</span>`
          );
        }

        if (highlightURL.checked) {
          const urlRegex = /\b(?:https?|ftp):\/\/[^\s<>"{}|\\^`\[\]]+/gi;
          highlighted = highlighted.replace(
            urlRegex,
            (match) => `<span class="hl-url">${match}</span>`
          );
        }

        if (highlightEmail.checked) {
          const emailRegex =
            /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
          highlighted = highlighted.replace(
            emailRegex,
            (match) => `<span class="hl-email">${match}</span>`
          );
        }

        const lines = highlighted.split("\n");
        const processedLines = lines.map((line) => {
          if (highlightX.checked) {
            const xHeaderMatch = line.match(/^(X-[^:]+)(:)/i);
            if (xHeaderMatch) {
              return line.replace(
                /^(X-[^:]+)(:)/i,
                '<span class="hl-x-header">$1$2</span>'
              );
            }
          }

          if (highlightCommon.checked) {
            for (const header of commonHeaders) {
              const regex = new RegExp(`^\\b(${header})\\b(:)`, "i");
              if (regex.test(line)) {
                return line.replace(
                  regex,
                  '<span class="hl-common-header">$1$2</span>'
                );
              }
            }
          }

          if (highlightOther.checked) {
            for (const header of otherHeaders) {
              const regex = new RegExp(`^\\b(${header})\\b(:)`, "i");
              if (regex.test(line)) {
                return line.replace(
                  regex,
                  '<span class="hl-other-header">$1$2</span>'
                );
              }
            }
          }

          return line;
        });

        return processedLines.join("\n");
      }

      function updateOutput() {
        const text = input.value;
        output.innerHTML = highlightText(text);
      }

      function clearInput() {
        input.value = "";
        updateOutput();
        parseHeaders("");
      }

      function loadFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          input.value = e.target.result;
          updateOutput();
          parseHeaders(e.target.result);
        };
        reader.readAsText(file);
      }

      input.addEventListener("input", updateOutput);
      fileInput.addEventListener("change", loadFromFile);
      clearBtn.addEventListener("click", clearInput);

      highlightCommon.addEventListener("change", updateOutput);
      highlightOther.addEventListener("change", updateOutput);
      highlightX.addEventListener("change", updateOutput);
      highlightIPv4.addEventListener("change", updateOutput);
      highlightIPv6.addEventListener("change", updateOutput);
      highlightEmail.addEventListener("change", updateOutput);
      highlightURL.addEventListener("change", updateOutput);

      updateOutput();

      // Collapsible functionality
      function toggleCollapsible(header, content) {
        header.addEventListener("click", () => {
          header.classList.toggle("collapsed");
          content.classList.toggle("collapsed");
        });
      }

      const summaryHeader = document.getElementById("summaryHeader");
      const summaryContent = document.getElementById("summaryContent");
      const receivedHeader = document.getElementById("receivedHeader");
      const receivedContent = document.getElementById("receivedContent");
      const otherHeadersHeader = document.getElementById("otherHeadersHeader");
      const otherHeadersContent = document.getElementById(
        "otherHeadersContent"
      );

      toggleCollapsible(summaryHeader, summaryContent);
      toggleCollapsible(receivedHeader, receivedContent);
      toggleCollapsible(otherHeadersHeader, otherHeadersContent);

      // Parse email headers and populate tables
      function parseHeaders(text) {
        if (!text.trim()) {
          document.getElementById("summarySection").style.display = "none";
          document.getElementById("receivedSection").style.display = "none";
          document.getElementById("otherHeadersSection").style.display = "none";
          return;
        }

        const lines = text.split("\n");
        const headers = {};
        let currentHeader = null;
        let currentValue = "";

        for (const line of lines) {
          // Stop parsing at the first blank line (end of headers)
          if (line.trim() === "" && currentHeader) {
            break;
          }

          if (line.match(/^[A-Za-z0-9-]+:/)) {
            if (currentHeader) {
              if (!headers[currentHeader]) {
                headers[currentHeader] = [];
              }
              headers[currentHeader].push(currentValue.trim());
            }
            const colonIndex = line.indexOf(":");
            currentHeader = line.substring(0, colonIndex).trim();
            currentValue = line.substring(colonIndex + 1).trim();
          } else if (currentHeader && line.trim()) {
            currentValue += " " + line.trim();
          }
        }

        if (currentHeader) {
          if (!headers[currentHeader]) {
            headers[currentHeader] = [];
          }
          headers[currentHeader].push(currentValue.trim());
        }

        populateSummary(headers);
        populateReceived(headers);
        populateOtherHeaders(headers);
      }

      // Decode RFC 2047 encoded headers (like Subject)
      function decodeHeader(value) {
        // Decode =?charset?encoding?text?= format
        const encodedWordRegex = /=\?([^?]+)\?([BQ])\?([^?]*)\?=/gi;
        return value.replace(
          encodedWordRegex,
          (match, charset, encoding, text) => {
            try {
              if (encoding.toUpperCase() === "B") {
                // Base64 decoding
                return decodeURIComponent(escape(atob(text)));
              } else if (encoding.toUpperCase() === "Q") {
                // Quoted-printable decoding
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9A-F]{2})/g, (m, hex) => {
                  return String.fromCharCode(parseInt(hex, 16));
                });
                return text;
              }
            } catch (e) {
              return match;
            }
            return match;
          }
        );
      }

      function populateSummary(headers) {
        const summaryTable = document
          .getElementById("summaryTable")
          .getElementsByTagName("tbody")[0];
        summaryTable.innerHTML = "";

        const summaryFields = {
          Subject: "Subject",
          "Message-ID": "Message Id",
          Date: "Creation time",
          From: "From",
          To: "To",
        };

        let hasData = false;
        for (const [key, label] of Object.entries(summaryFields)) {
          if (headers[key] && headers[key].length > 0) {
            hasData = true;
            const row = summaryTable.insertRow();
            const cell1 = row.insertCell(0);
            const cell2 = row.insertCell(1);
            cell1.textContent = label;
            // Decode the header value (especially for Subject)
            cell2.textContent = decodeHeader(headers[key][0]);
          }
        }

        document.getElementById("summarySection").style.display = hasData
          ? "block"
          : "none";
      }

      function populateReceived(headers) {
        const receivedTable = document
          .getElementById("receivedTable")
          .getElementsByTagName("tbody")[0];
        receivedTable.innerHTML = "";

        if (!headers["Received"] || headers["Received"].length === 0) {
          document.getElementById("receivedSection").style.display = "none";
          return;
        }

        document.getElementById("receivedSection").style.display = "block";

        // Reverse the order (most recent first)
        const received = [...headers["Received"]].reverse();
        let previousTime = null;

        received.forEach((value, index) => {
          const row = receivedTable.insertRow();

          // Hop number
          row.insertCell(0).textContent = index + 1;

          // Extract submitting host (from) - get everything after "from" until "by"
          let fromText = "";
          const fromMatch = value.match(/from\s+(.+?)\s+by\s+/i);
          if (fromMatch) {
            fromText = fromMatch[1].trim();
          }
          row.insertCell(1).textContent = fromText;

          // Extract receiving host (by) - get everything after "by" until "with" or "id" or ";"
          let byText = "";
          const byMatch = value.match(/by\s+(.+?)(?:\s+with|\s+id|\s+\(|;)/i);
          if (byMatch) {
            byText = byMatch[1].trim();
          } else {
            // Fallback if no match
            const bySimpleMatch = value.match(/by\s+([^\s]+)/i);
            if (bySimpleMatch) {
              byText = bySimpleMatch[1];
            }
          }
          row.insertCell(2).textContent = byText;

          // Extract time - everything after the semicolon
          const dateMatch = value.match(/;\s*(.+)$/);
          const timeText = dateMatch ? dateMatch[1].trim() : "";

          // Format date if possible
          let formattedDate = timeText;
          try {
            const parsedDate = new Date(timeText);
            if (!isNaN(parsedDate.getTime())) {
              formattedDate = parsedDate.toLocaleString("en-US", {
                month: "numeric",
                day: "numeric",
                year: "numeric",
                hour: "numeric",
                minute: "numeric",
                second: "numeric",
                hour12: true,
              });
            }
          } catch (e) {
            // Keep original if parsing fails
          }
          row.insertCell(3).textContent = formattedDate;

          // Calculate delay
          const delayCell = row.insertCell(4);
          if (previousTime && timeText) {
            try {
              const currentDate = new Date(timeText);
              const prevDate = new Date(previousTime);
              const diffMs = Math.abs(currentDate - prevDate);
              const diffSeconds = Math.floor(diffMs / 1000);
              if (diffSeconds === 0) {
                delayCell.textContent = "0 seconds";
              } else if (diffSeconds === 1) {
                delayCell.textContent = "1 second";
              } else {
                delayCell.textContent = diffSeconds + " seconds";
              }
            } catch (e) {
              delayCell.textContent = "";
            }
          } else {
            delayCell.textContent = "";
          }
          previousTime = timeText;

          // Extract type (protocol)
          const withMatch = value.match(/with\s+([^\s]+)/i);
          row.insertCell(5).textContent = withMatch
            ? withMatch[1].toUpperCase()
            : "";
        });
      }

      function populateOtherHeaders(headers) {
        const otherHeadersTable = document
          .getElementById("otherHeadersTable")
          .getElementsByTagName("tbody")[0];
        otherHeadersTable.innerHTML = "";

        const excludeHeaders = [
          "Subject",
          "Message-ID",
          "Date",
          "From",
          "To",
          "Received",
        ];
        let rowNum = 1;
        let hasData = false;
        const seenHeaders = new Set();

        for (const [key, values] of Object.entries(headers)) {
          if (!excludeHeaders.includes(key)) {
            // Only show the first occurrence of each header
            if (!seenHeaders.has(key)) {
              seenHeaders.add(key);
              hasData = true;
              const row = otherHeadersTable.insertRow();
              row.insertCell(0).textContent = rowNum++;
              row.insertCell(1).textContent = key;
              row.insertCell(2).textContent = decodeHeader(values[0]);
            }
          }
        }

        document.getElementById("otherHeadersSection").style.display = hasData
          ? "block"
          : "none";
      }

      // Update parseHeaders when input changes
      input.addEventListener("input", () => {
        parseHeaders(input.value);
      });

      // Initial parse
      parseHeaders(input.value);
    </script>
  </body>
</html>
