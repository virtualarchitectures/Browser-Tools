<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Definition Extractor</title>

    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        line-height: 1.6;
        max-width: 980px;
        margin: 0 auto;
        padding: 20px;
        color: #24292e;
        background: #ffffff;
      }
      h1 {
        border-bottom: 1px solid #eaecef;
        padding-bottom: 0.3em;
        margin-top: 0;
        font-size: 32px;
        font-weight: 600;
      }
      .back-link {
        display: inline-block;
        margin-bottom: 16px;
        color: #0366d6;
        text-decoration: none;
        font-size: 14px;
      }
      .back-link:hover {
        text-decoration: underline;
      }
      .instruction {
        background: #f6f8fa;
        padding: 16px;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 20px;
        font-size: 14px;
        color: #586069;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }
      input[type="file"] {
        display: none;
      }
      .btn {
        background: #fafbfc;
        color: #24292e;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        text-decoration: none;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      .btn:hover {
        background: #f3f4f6;
      }
      .btn.primary {
        background: #0366d6;
        color: #fff;
        border: 1px solid rgba(27, 31, 35, 0.15);
      }
      .btn.primary:hover {
        background: #0256c5;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn.primary:disabled:hover {
        background: #0366d6;
      }
      label.btn {
        margin: 0;
      }
      .panel {
        background: #f6f8fa;
        padding: 16px;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 16px;
      }
      .panel h2 {
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 20px;
        font-weight: 600;
        color: #24292e;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .panel h2::before {
        content: "▼";
        display: inline-block;
        font-size: 12px;
        transition: transform 0.2s;
      }
      .panel h2.collapsed::before {
        transform: rotate(-90deg);
      }
      .panel-content {
        transition: max-height 0.3s ease;
      }
      .panel-content.collapsed {
        display: none;
      }
      .search-input {
        margin-bottom: 16px;
      }
      .search-input label {
        display: block;
        font-weight: 600;
        margin-bottom: 4px;
        font-size: 14px;
      }
      .search-input input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        font-size: 14px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      .search-input input:focus {
        outline: none;
        border-color: #0366d6;
        box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1);
      }
      .option-group {
        margin-bottom: 12px;
      }
      .option-group:last-child {
        margin-bottom: 0;
      }
      .option-group label {
        display: block;
        font-weight: 600;
        margin-bottom: 4px;
        font-size: 14px;
      }
      .checkbox-group {
        margin-bottom: 8px;
      }
      .checkbox-group label {
        display: flex;
        align-items: center;
        gap: 8px;
        font-weight: normal;
        cursor: pointer;
      }
      .checkbox-group input[type="checkbox"] {
        cursor: pointer;
      }
      .option-description {
        font-size: 12px;
        color: #586069;
        margin-top: 4px;
      }
      .action-buttons {
        display: flex;
        gap: 8px;
        margin-top: 16px;
      }
      .results-section {
        margin-top: 20px;
      }
      .empty-state {
        text-align: center;
        color: #586069;
        padding: 40px 20px;
      }
      .definition-item {
        background: #ffffff;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        padding: 16px;
        margin-bottom: 12px;
        transition: border-color 0.2s;
      }
      .definition-item:hover {
        border-color: #0366d6;
      }
      .definition-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 8px;
        gap: 12px;
      }
      .definition-type {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
      }
      .definition-type.explicit {
        background: #dcffe4;
        color: #0e6027;
      }
      .definition-type.implicit {
        background: #fff5b1;
        color: #735c0f;
      }
      .definition-type.descriptive {
        background: #d1e7ff;
        color: #0e4a86;
      }
      .definition-term {
        font-weight: 600;
        font-size: 16px;
        color: #24292e;
        margin-bottom: 8px;
      }
      .definition-text {
        color: #24292e;
        margin-bottom: 8px;
        line-height: 1.6;
      }
      .definition-context {
        font-size: 13px;
        color: #586069;
        font-style: italic;
        background: #f6f8fa;
        padding: 8px;
        border-radius: 4px;
        border-left: 3px solid #e1e4e8;
        margin-top: 8px;
      }
      .definition-meta {
        display: flex;
        gap: 16px;
        font-size: 12px;
        color: #586069;
        margin-top: 8px;
        flex-wrap: wrap;
      }
      .definition-meta span {
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .confidence-bar {
        width: 60px;
        height: 4px;
        background: #e1e4e8;
        border-radius: 2px;
        overflow: hidden;
        display: inline-block;
      }
      .confidence-fill {
        height: 100%;
        background: #28a745;
        transition: width 0.3s;
      }
      .confidence-fill.medium {
        background: #ffd33d;
      }
      .confidence-fill.low {
        background: #d73a49;
      }
      .summary-stats {
        display: flex;
        gap: 16px;
        margin-bottom: 16px;
        flex-wrap: wrap;
      }
      .stat-item {
        background: #ffffff;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        padding: 12px 16px;
        flex: 1;
        min-width: 150px;
      }
      .stat-value {
        font-size: 24px;
        font-weight: 600;
        color: #24292e;
      }
      .stat-label {
        font-size: 12px;
        color: #586069;
        margin-top: 4px;
      }
      .filter-controls {
        margin-bottom: 16px;
        padding: 12px;
        background: #f6f8fa;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
      }
      .filter-controls label {
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 8px;
        display: block;
      }
      .filter-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .filter-btn {
        padding: 6px 12px;
        border-radius: 4px;
        border: 1px solid #e1e4e8;
        background: #ffffff;
        cursor: pointer;
        font-size: 13px;
        transition: all 0.2s;
      }
      .filter-btn:hover {
        background: #f3f4f6;
      }
      .filter-btn.active {
        background: #0366d6;
        color: #ffffff;
        border-color: #0366d6;
      }
      .text-input-section {
        margin-bottom: 16px;
      }
      .text-input-section label {
        display: block;
        font-weight: 600;
        margin-bottom: 8px;
        font-size: 14px;
      }
      .text-input-section textarea {
        width: 100%;
        min-height: 200px;
        padding: 12px;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        font-size: 14px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        line-height: 1.6;
        resize: vertical;
      }
      .text-input-section textarea:focus {
        outline: none;
        border-color: #0366d6;
        box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1);
      }
      .input-tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
      }
      .tab-btn {
        padding: 8px 16px;
        border: 1px solid #e1e4e8;
        background: #fafbfc;
        border-radius: 6px 6px 0 0;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
      }
      .tab-btn:hover {
        background: #f3f4f6;
      }
      .tab-btn.active {
        background: #ffffff;
        border-bottom-color: #ffffff;
        font-weight: 600;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      @media (max-width: 768px) {
        .summary-stats {
          flex-direction: column;
        }
        .definition-header {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-link">← Back to Tools</a>

    <h1>Definition Extractor</h1>

    <div class="instruction">
      Extract explicit and implicit definitions from text documents. This tool
      uses natural language processing patterns to identify definitions like "A
      digital twin is...", "Digital twin refers to...", and descriptive phrases
      that define terms in context.
    </div>

    <!-- Input Section -->
    <div class="panel">
      <h2 id="input-header">Input Text</h2>
      <div class="panel-content" id="input-content">
        <div class="controls" style="margin-bottom: 12px">
          <label for="file-input" class="btn primary">Load File</label>
          <input type="file" id="file-input" accept=".txt,.md" />
          <span id="file-name"></span>
          <button id="clear-file" class="btn" style="display: none">
            Clear
          </button>
        </div>

        <div class="text-input-section">
          <label for="text-input">Enter or paste text:</label>
          <textarea
            id="text-input"
            placeholder="Paste your text here to extract definitions..."
          ></textarea>
        </div>
      </div>
    </div>

    <!-- Configuration Panel -->
    <div class="panel">
      <h2 id="config-header">Configuration</h2>
      <div class="panel-content" id="config-content">
        <div class="search-input">
          <label for="search-term"
            >Search Term (optional - leave empty to find all
            definitions):</label
          >
          <input
            type="text"
            id="search-term"
            placeholder="e.g., Digital Twin, Machine Learning, API"
          />
          <div class="option-description">
            Specify a term to find its definitions, or leave blank to extract
            all definitions from the text.
          </div>
        </div>

        <div class="option-group">
          <label>Definition Types to Include:</label>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="include-explicit" checked />
              Explicit Definitions (e.g., "X is...", "X means...", "X refers
              to...")
            </label>
          </div>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="include-implicit" checked />
              Implicit Definitions (e.g., "X, which is...", "X - a type of...")
            </label>
          </div>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="include-descriptive" checked />
              Descriptive Definitions (e.g., "X can be described as...", "X
              consists of...")
            </label>
          </div>
        </div>

        <div class="option-group">
          <label>Options:</label>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="case-sensitive" />
              Case-sensitive matching
            </label>
          </div>
          <div class="checkbox-group">
            <label>
              <input type="checkbox" id="show-context" checked />
              Show surrounding context
            </label>
          </div>
        </div>

        <div class="action-buttons">
          <button id="extract-btn" class="btn primary">
            Extract Definitions
          </button>
          <button id="clear-btn" class="btn">Clear All</button>
        </div>
      </div>
    </div>

    <!-- Results Section -->
    <div class="results-section" id="results-section" style="display: none">
      <div class="panel">
        <h2 id="results-header">Results</h2>
        <div class="panel-content" id="results-content">
          <div class="summary-stats" id="summary-stats"></div>

          <div class="filter-controls">
            <label>Filter by Type:</label>
            <div class="filter-buttons">
              <button class="filter-btn active" data-filter="all">All</button>
              <button class="filter-btn" data-filter="explicit">
                Explicit
              </button>
              <button class="filter-btn" data-filter="implicit">
                Implicit
              </button>
              <button class="filter-btn" data-filter="descriptive">
                Descriptive
              </button>
            </div>
          </div>

          <div id="definitions-container"></div>

          <div class="action-buttons">
            <button id="download-json" class="btn">Download as JSON</button>
            <button id="download-csv" class="btn">Download as CSV</button>
          </div>
        </div>
      </div>
    </div>

    <div class="empty-state" id="empty-state">
      Load a text file or paste text, then click "Extract Definitions" to begin.
    </div>

    <script>
      // =========================
      // Global Variables
      // =========================
      let currentText = "";
      let extractedDefinitions = [];

      // =========================
      // DOM Elements
      // =========================
      const fileInput = document.getElementById("file-input");
      const fileName = document.getElementById("file-name");
      const clearFileBtn = document.getElementById("clear-file");
      const textInput = document.getElementById("text-input");
      const searchTerm = document.getElementById("search-term");
      const includeExplicit = document.getElementById("include-explicit");
      const includeImplicit = document.getElementById("include-implicit");
      const includeDescriptive = document.getElementById("include-descriptive");
      const caseSensitive = document.getElementById("case-sensitive");
      const showContext = document.getElementById("show-context");
      const extractBtn = document.getElementById("extract-btn");
      const clearBtn = document.getElementById("clear-btn");
      const resultsSection = document.getElementById("results-section");
      const emptyState = document.getElementById("empty-state");
      const definitionsContainer = document.getElementById(
        "definitions-container"
      );
      const summaryStats = document.getElementById("summary-stats");
      const downloadJsonBtn = document.getElementById("download-json");
      const downloadCsvBtn = document.getElementById("download-csv");
      const filterBtns = document.querySelectorAll(".filter-btn");

      // =========================
      // Collapsible Panels
      // =========================
      const panels = [
        { header: "input-header", content: "input-content" },
        { header: "config-header", content: "config-content" },
        { header: "results-header", content: "results-content" },
      ];

      panels.forEach(({ header, content }) => {
        const headerEl = document.getElementById(header);
        const contentEl = document.getElementById(content);
        if (headerEl && contentEl) {
          headerEl.addEventListener("click", () => {
            headerEl.classList.toggle("collapsed");
            contentEl.classList.toggle("collapsed");
          });
        }
      });

      // =========================
      // File Upload
      // =========================
      fileInput.addEventListener("change", handleFileSelect);
      clearFileBtn.addEventListener("click", clearFile);

      function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
          fileName.textContent = file.name;
          clearFileBtn.style.display = "inline-block";

          const reader = new FileReader();
          reader.onload = function (e) {
            currentText = e.target.result;
            textInput.value = currentText;
          };
          reader.readAsText(file);
        }
      }

      function clearFile() {
        fileInput.value = "";
        fileName.textContent = "";
        clearFileBtn.style.display = "none";
        currentText = "";
        textInput.value = "";
      }

      // =========================
      // Text Input
      // =========================
      textInput.addEventListener("input", (e) => {
        currentText = e.target.value;
      });

      // =========================
      // Definition Extraction Logic
      // =========================
      function extractDefinitions() {
        const term = searchTerm.value.trim();
        const text = currentText;

        if (!text) {
          alert("Please provide some text to analyze.");
          return;
        }

        const definitions = [];

        // Split text into sentences
        const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];

        // Escape special regex characters in search term
        const escapedTerm = term
          ? term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
          : null;

        // Build regex pattern for the term (if provided)
        const termPattern = escapedTerm
          ? caseSensitive.checked
            ? new RegExp(`\\b${escapedTerm}\\b`, "g")
            : new RegExp(`\\b${escapedTerm}\\b`, "gi")
          : null;

        // Extract explicit definitions
        if (includeExplicit.checked) {
          const explicitPatterns = [
            // "X is [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+(?:is|are|was|were)\\s+(?:a|an|the)?\\s*([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+(?:is|are|was|were)\s+(?:a|an|the)?\s*([^.!?]+[.!?])/g,
              type: "explicit",
            },
            // "X means [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+means\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+means\s+([^.!?]+[.!?])/g,
              type: "explicit",
            },
            // "X refers to [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+refers?\\s+to\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+refers?\s+to\s+([^.!?]+[.!?])/g,
              type: "explicit",
            },
            // "X is defined as [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+(?:is|are)\\s+defined\\s+as\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+(?:is|are)\s+defined\s+as\s+([^.!?]+[.!?])/g,
              type: "explicit",
            },
            // "The term X [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(?:the\\s+term|the\\s+concept(?:\\s+of)?)\\s+(${escapedTerm})\\s+(?:is|means|refers\\s+to)\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /(?:the\s+term|the\s+concept(?:\s+of)?)\s+([A-Z][a-zA-Z\s]+?)\s+(?:is|means|refers\s+to)\s+([^.!?]+[.!?])/g,
              type: "explicit",
            },
          ];

          explicitPatterns.forEach(({ pattern, type }) => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
              const term = match[1].trim();
              const definition = match[2].trim();
              const startIndex = match.index;
              const endIndex = startIndex + match[0].length;

              definitions.push({
                term: term,
                definition: definition,
                type: type,
                confidence: 0.9,
                context: extractContext(text, startIndex, endIndex),
                sentence: extractSentence(text, startIndex, endIndex),
                position: startIndex,
              });
            }
          });
        }

        // Extract implicit definitions
        if (includeImplicit.checked) {
          const implicitPatterns = [
            // "X, which is [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm}),?\\s+which\\s+(?:is|are|was|were)\\s+([^,]+(?:,[^,]+)?)`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?),?\s+which\s+(?:is|are|was|were)\s+([^,]+(?:,[^,]+)?)/g,
              type: "implicit",
            },
            // "X - [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s*[-–—]\\s*(?:a|an|the)?\\s*([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s*[-–—]\s*(?:a|an|the)?\s*([^.!?]+[.!?])/g,
              type: "implicit",
            },
            // "X (definition)"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s*\\(([^)]{20,})\\)`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s*\(([^)]{20,})\)/g,
              type: "implicit",
            },
            // "X, or [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm}),\\s*or\\s+([^,]+(?:,[^,]+)?)`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?),\s*or\s+([^,]+(?:,[^,]+)?)/g,
              type: "implicit",
            },
          ];

          implicitPatterns.forEach(({ pattern, type }) => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
              const term = match[1].trim();
              const definition = match[2].trim();
              const startIndex = match.index;
              const endIndex = startIndex + match[0].length;

              definitions.push({
                term: term,
                definition: definition,
                type: type,
                confidence: 0.7,
                context: extractContext(text, startIndex, endIndex),
                sentence: extractSentence(text, startIndex, endIndex),
                position: startIndex,
              });
            }
          });
        }

        // Extract descriptive definitions
        if (includeDescriptive.checked) {
          const descriptivePatterns = [
            // "X can be described as [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+can\\s+be\\s+(?:described|defined|characterized)\\s+as\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+can\s+be\s+(?:described|defined|characterized)\s+as\s+([^.!?]+[.!?])/g,
              type: "descriptive",
            },
            // "X consists of [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+consists?\\s+of\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+consists?\s+of\s+([^.!?]+[.!?])/g,
              type: "descriptive",
            },
            // "X represents [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+represents?\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+represents?\s+([^.!?]+[.!?])/g,
              type: "descriptive",
            },
            // "X involves [definition]"
            {
              pattern: escapedTerm
                ? new RegExp(
                    `(${escapedTerm})\\s+involves?\\s+([^.!?]+[.!?])`,
                    caseSensitive.checked ? "g" : "gi"
                  )
                : /\b([A-Z][a-zA-Z\s]+?)\s+involves?\s+([^.!?]+[.!?])/g,
              type: "descriptive",
            },
          ];

          descriptivePatterns.forEach(({ pattern, type }) => {
            let match;
            while ((match = pattern.exec(text)) !== null) {
              const term = match[1].trim();
              const definition = match[2].trim();
              const startIndex = match.index;
              const endIndex = startIndex + match[0].length;

              definitions.push({
                term: term,
                definition: definition,
                type: type,
                confidence: 0.75,
                context: extractContext(text, startIndex, endIndex),
                sentence: extractSentence(text, startIndex, endIndex),
                position: startIndex,
              });
            }
          });
        }

        // Remove duplicates and sort by position
        const uniqueDefinitions = removeDuplicates(definitions);
        uniqueDefinitions.sort((a, b) => a.position - b.position);

        extractedDefinitions = uniqueDefinitions;
        displayResults();
      }

      function extractSentence(text, startIndex, endIndex) {
        // Find the start of the sentence (look backward for sentence boundary)
        let sentenceStart = startIndex;
        for (let i = startIndex - 1; i >= 0; i--) {
          const char = text[i];
          const nextChar = i + 1 < text.length ? text[i + 1] : "";

          // Found a sentence boundary (period/!/?  followed by space and capital letter or newline)
          if (
            (char === "." || char === "!" || char === "?") &&
            (nextChar === " " || nextChar === "\n" || nextChar === "\r")
          ) {
            // Check if next non-whitespace char is uppercase or it's the end
            let j = i + 1;
            while (j < text.length && /\s/.test(text[j])) j++;
            if (j >= text.length || /[A-Z]/.test(text[j])) {
              sentenceStart = i + 1;
              break;
            }
          }
          // Beginning of text
          if (i === 0) {
            sentenceStart = 0;
            break;
          }
        }

        // Find the end of the sentence (look forward for sentence boundary)
        // Start from the beginning of the match to ensure we don't miss anything
        let sentenceEnd = text.length;
        for (let i = startIndex; i < text.length; i++) {
          const char = text[i];
          const nextChar = i + 1 < text.length ? text[i + 1] : "";

          // Found a sentence boundary (period/!/?  followed by space and capital letter or newline or end)
          if (char === "." || char === "!" || char === "?") {
            // Check if this is followed by whitespace and then uppercase, or end of text
            let j = i + 1;
            while (j < text.length && /\s/.test(text[j])) j++;

            if (
              j >= text.length ||
              /[A-Z]/.test(text[j]) ||
              text[j] === '"' ||
              text[j] === "'"
            ) {
              sentenceEnd = i + 1;
              break;
            }
          }
        }

        let sentence = text.substring(sentenceStart, sentenceEnd).trim();
        return sentence;
      }

      function extractContext(text, startIndex, endIndex) {
        if (!showContext.checked) return null;

        // Find the sentence boundaries for the main sentence containing the definition
        // Use the actual match position, not indexOf which could find wrong occurrence
        let mainSentenceStart = startIndex;
        let mainSentenceEnd = endIndex;

        // Find the actual start of the sentence (look backward from startIndex)
        for (let i = startIndex - 1; i >= 0; i--) {
          const char = text[i];
          const nextChar = i + 1 < text.length ? text[i + 1] : "";

          if (
            (char === "." || char === "!" || char === "?") &&
            (nextChar === " " || nextChar === "\n" || nextChar === "\r")
          ) {
            let j = i + 1;
            while (j < text.length && /\s/.test(text[j])) j++;
            if (j >= text.length || /[A-Z]/.test(text[j])) {
              mainSentenceStart = i + 1;
              break;
            }
          }

          if (i === 0) {
            mainSentenceStart = 0;
            break;
          }
        }

        // Find the actual end of the sentence (look forward from startIndex)
        for (let i = startIndex; i < text.length; i++) {
          const char = text[i];
          const nextChar = i + 1 < text.length ? text[i + 1] : "";

          if (char === "." || char === "!" || char === "?") {
            let j = i + 1;
            while (j < text.length && /\s/.test(text[j])) j++;

            if (
              j >= text.length ||
              /[A-Z]/.test(text[j]) ||
              text[j] === '"' ||
              text[j] === "'"
            ) {
              mainSentenceEnd = i + 1;
              break;
            }
          }
        }

        // Limit how far back we search (500 chars max)
        const searchBackwardLimit = Math.max(0, mainSentenceStart - 500);

        // Find the previous sentence (if exists)
        let contextStart = mainSentenceStart;
        let sentenceCount = 0;
        const maxPreviousSentences = 1;

        if (mainSentenceStart > 0) {
          // Look backward from the main sentence to find previous sentence
          for (let i = mainSentenceStart - 1; i >= searchBackwardLimit; i--) {
            const char = text[i];
            const nextChar = i + 1 < text.length ? text[i + 1] : "";

            if (
              (char === "." || char === "!" || char === "?") &&
              (nextChar === " " || nextChar === "\n" || nextChar === "\r")
            ) {
              let j = i + 1;
              while (j < text.length && /\s/.test(text[j])) j++;
              if (j >= text.length || /[A-Z]/.test(text[j])) {
                sentenceCount++;
                if (sentenceCount >= maxPreviousSentences) {
                  contextStart = i + 1;
                  break;
                }
              }
            }

            if (i === searchBackwardLimit) {
              contextStart = searchBackwardLimit;
              break;
            }
          }
        }

        // Limit how far forward we search (1000 chars max for 2 sentences)
        const searchForwardLimit = Math.min(
          text.length,
          mainSentenceEnd + 1000
        );

        // Find the next sentence (if exists)
        let contextEnd = mainSentenceEnd;
        sentenceCount = 0;
        const maxNextSentences = 2;

        for (let i = mainSentenceEnd; i < searchForwardLimit; i++) {
          const char = text[i];
          const nextChar = i + 1 < text.length ? text[i + 1] : "";

          if (char === "." || char === "!" || char === "?") {
            let j = i + 1;
            while (j < text.length && /\s/.test(text[j])) j++;

            if (
              j >= text.length ||
              /[A-Z]/.test(text[j]) ||
              text[j] === '"' ||
              text[j] === "'"
            ) {
              sentenceCount++;
              if (sentenceCount >= maxNextSentences) {
                contextEnd = i + 1;
                break;
              }
            }
          }

          if (i === searchForwardLimit - 1) {
            contextEnd = searchForwardLimit;
            break;
          }
        }

        let context = text.substring(contextStart, contextEnd).trim();

        // Add ellipsis if truncated
        if (contextStart > 0) context = "..." + context;
        if (contextEnd < text.length) context = context + "...";

        return context;
      }

      function removeDuplicates(definitions) {
        const seen = new Set();
        return definitions.filter((def) => {
          const key = `${def.term.toLowerCase()}:${def.definition.toLowerCase()}`;
          if (seen.has(key)) {
            return false;
          }
          seen.add(key);
          return true;
        });
      }

      // =========================
      // Display Results
      // =========================
      function displayResults() {
        if (extractedDefinitions.length === 0) {
          resultsSection.style.display = "none";
          emptyState.style.display = "block";
          emptyState.textContent =
            "No definitions found. Try adjusting your search term or definition type filters.";
          return;
        }

        resultsSection.style.display = "block";
        emptyState.style.display = "none";

        // Update summary statistics
        const stats = {
          total: extractedDefinitions.length,
          explicit: extractedDefinitions.filter((d) => d.type === "explicit")
            .length,
          implicit: extractedDefinitions.filter((d) => d.type === "implicit")
            .length,
          descriptive: extractedDefinitions.filter(
            (d) => d.type === "descriptive"
          ).length,
        };

        summaryStats.innerHTML = `
          <div class="stat-item">
            <div class="stat-value">${stats.total}</div>
            <div class="stat-label">Total Definitions</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${stats.explicit}</div>
            <div class="stat-label">Explicit</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${stats.implicit}</div>
            <div class="stat-label">Implicit</div>
          </div>
          <div class="stat-item">
            <div class="stat-value">${stats.descriptive}</div>
            <div class="stat-label">Descriptive</div>
          </div>
        `;

        renderDefinitions();
      }

      function renderDefinitions(filter = "all") {
        const filtered =
          filter === "all"
            ? extractedDefinitions
            : extractedDefinitions.filter((d) => d.type === filter);

        if (filtered.length === 0) {
          definitionsContainer.innerHTML = `
            <div class="empty-state">
              No definitions match the selected filter.
            </div>
          `;
          return;
        }

        definitionsContainer.innerHTML = filtered
          .map((def, index) => {
            const confidenceClass =
              def.confidence >= 0.8
                ? "high"
                : def.confidence >= 0.6
                ? "medium"
                : "low";

            return `
            <div class="definition-item">
              <div class="definition-header">
                <div class="definition-term">${escapeHtml(def.term)}</div>
                <span class="definition-type ${def.type}">${def.type}</span>
              </div>
              ${
                def.sentence
                  ? `<div class="definition-text">${escapeHtml(
                      def.sentence
                    )}</div>`
                  : `<div class="definition-text">${escapeHtml(
                      def.definition
                    )}</div>`
              }
              ${
                def.context && showContext.checked
                  ? `<div class="definition-context" style="margin-top: 8px;"><strong>Context:</strong> ${escapeHtml(
                      def.context
                    )}</div>`
                  : ""
              }
              <div class="definition-meta">
                <span>
                  Confidence:
                  <span class="confidence-bar">
                    <span class="confidence-fill ${confidenceClass}"
                          style="width: ${def.confidence * 100}%"></span>
                  </span>
                  ${Math.round(def.confidence * 100)}%
                </span>
                <span>Position: ${def.position}</span>
              </div>
            </div>
          `;
          })
          .join("");
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // =========================
      // Filter Functionality
      // =========================
      filterBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          filterBtns.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");

          const filter = btn.dataset.filter;
          renderDefinitions(filter);
        });
      });

      // =========================
      // Export Functions
      // =========================
      function downloadJSON() {
        const dataStr = JSON.stringify(extractedDefinitions, null, 2);
        const blob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "definitions.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function downloadCSV() {
        const headers = [
          "Term",
          "Definition",
          "Type",
          "Confidence",
          "Position",
        ];
        const rows = extractedDefinitions.map((def) => [
          escapeCSV(def.term),
          escapeCSV(def.sentence || def.definition),
          def.type,
          def.confidence,
          def.position,
        ]);

        const csvContent = [
          headers.join(","),
          ...rows.map((row) => row.join(",")),
        ].join("\n");

        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "definitions.csv";
        a.click();
        URL.revokeObjectURL(url);
      }

      function escapeCSV(str) {
        // Replace newlines and carriage returns with spaces
        let cleaned = str
          .replace(/[\r\n]+/g, " ")
          .replace(/\s+/g, " ")
          .trim();

        if (cleaned.includes(",") || cleaned.includes('"')) {
          return `"${cleaned.replace(/"/g, '""')}"`;
        }
        return cleaned;
      }

      // =========================
      // Event Listeners
      // =========================
      extractBtn.addEventListener("click", extractDefinitions);
      downloadJsonBtn.addEventListener("click", downloadJSON);
      downloadCsvBtn.addEventListener("click", downloadCSV);

      clearBtn.addEventListener("click", () => {
        currentText = "";
        textInput.value = "";
        searchTerm.value = "";
        extractedDefinitions = [];
        definitionsContainer.innerHTML = "";
        resultsSection.style.display = "none";
        emptyState.style.display = "block";
        emptyState.textContent =
          'Load a text file or paste text, then click "Extract Definitions" to begin.';
        clearFile();

        // Reset filters
        filterBtns.forEach((b) => b.classList.remove("active"));
        filterBtns[0].classList.add("active");
      });
    </script>
  </body>
</html>
