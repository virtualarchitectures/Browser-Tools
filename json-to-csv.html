<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JSON to CSV Converter</title>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        line-height: 1.6;
        max-width: 980px;
        margin: 0 auto;
        padding: 20px;
        color: #24292e;
        background: #ffffff;
      }
      h1 {
        border-bottom: 1px solid #eaecef;
        padding-bottom: 0.3em;
        margin-top: 0;
        font-size: 32px;
        font-weight: 600;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-bottom: 16px;
        flex-wrap: wrap;
        justify-content: space-between;
      }
      input[type="file"] {
        font-size: 16px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        color: transparent;
        width: auto;
        display: none;
      }
      input[type="file"]::file-selector-button {
        margin-right: 0;
        padding: 6px 12px;
        background: #fafbfc;
        color: #24292e;
        border: 1px solid rgba(27, 31, 35, 0.15);
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      input[type="file"]::file-selector-button:hover {
        background: #f3f4f6;
      }
      .btn {
        background: #fafbfc;
        color: #24292e;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        text-decoration: none;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      .btn:hover {
        background: #f3f4f6;
      }
      .btn.primary {
        background: #0366d6;
        color: #fff;
        border: 1px solid rgba(27, 31, 35, 0.15);
      }
      .btn.primary:hover {
        background: #0256c5;
      }
      .btn.secondary {
        background: #fafbfc;
        color: #24292e;
        border: 1px solid rgba(27, 31, 35, 0.15);
      }
      .btn.secondary:hover {
        background: #f3f4f6;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn.secondary:disabled:hover {
        background: #fafbfc;
      }
      .btn.primary:disabled:hover {
        background: #0366d6;
      }
      .panel {
        background: #f6f8fa;
        padding: 16px;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 16px;
      }
      .panel h2 {
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 20px;
        font-weight: 600;
        color: #24292e;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
      }
      .panel h2::before {
        content: "▼";
        display: inline-block;
        margin-right: 8px;
        transition: transform 0.2s;
        font-size: 12px;
      }
      .panel h2.collapsed::before {
        transform: rotate(-90deg);
      }
      .panel-content {
        transition: max-height 0.3s ease;
        overflow: hidden;
      }
      .panel-content.collapsed {
        display: none;
      }
      .table-wrapper {
        background: #ffffff;
        overflow-x: auto;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 12px;
        max-height: 400px;
        overflow-y: auto;
      }
      .data-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 14px;
      }
      .data-table th {
        background: #0366d6;
        padding: 10px 12px;
        text-align: left;
        font-weight: 600;
        color: #ffffff;
        border: 1px solid #0366d6;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      .data-table td {
        padding: 8px 12px;
        border: 1px solid #e1e4e8;
        color: #24292e;
      }
      .data-table tr:hover {
        background: #f6f8fa;
        cursor: pointer;
      }
      .json-output {
        background: #ffffff;
        padding: 12px;
        overflow-x: auto;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo,
          monospace;
        font-size: 14px;
        color: #24292e;
        margin: 0 0 12px 0;
        min-height: 250px;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .actions {
        display: flex;
        gap: 8px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      label.btn {
        display: inline-block;
        margin: 0;
      }
      .back-link {
        display: inline-block;
        margin-bottom: 16px;
        color: #0366d6;
        text-decoration: none;
        font-size: 14px;
      }
      .back-link:hover {
        text-decoration: underline;
      }
      .info {
        font-size: 13px;
        color: #586069;
        margin-bottom: 12px;
      }
      .empty-state {
        color: #586069;
        font-style: italic;
      }
      .options {
        background: #ffffff;
        padding: 12px;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 12px;
      }
      .option-group {
        margin-bottom: 12px;
      }
      .option-group:last-child {
        margin-bottom: 0;
      }
      .option-group label {
        display: block;
        margin-bottom: 6px;
        font-size: 14px;
        font-weight: 600;
        color: #24292e;
      }
      .option-group select {
        width: 100%;
        padding: 6px 12px;
        font-size: 16px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        background: #ffffff;
        color: #24292e;
      }
      .option-group select:focus {
        outline: none;
        border-color: #0366d6;
      }
      .option-description {
        font-size: 12px;
        color: #586069;
        margin-top: 4px;
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-link">← Back to Browser Tools</a>

    <h1>JSON to CSV Converter</h1>
    <div class="controls">
      <div>
        <label for="fileInput" class="btn primary">Load JSON</label>
        <input type="file" id="fileInput" accept=".json,application/json" />
      </div>
      <button class="btn secondary" id="clearBtn">Clear</button>
    </div>

    <div class="panel" id="optionsPanel">
      <h2 id="optionsHeader">Conversion Options</h2>
      <div class="panel-content" id="optionsContent">
        <div class="options">
          <div class="option-group" id="arrayPathGroup" style="display: none">
            <label for="arrayPath">Select Data to Convert</label>
            <select id="arrayPath">
              <option value="">-- Select data array --</option>
            </select>
            <div class="option-description">
              Your JSON contains multiple data structures. Select which one to
              convert to CSV.
            </div>
          </div>
          <div class="option-group">
            <label for="nestedHandling">Nested Object Handling</label>
            <select id="nestedHandling">
              <option value="flatten">
                Flatten with dot notation (e.g., user.name)
              </option>
              <option value="stringify">Convert to JSON strings</option>
              <option value="flattenDepth">Flatten with depth limit</option>
            </select>
            <div class="option-description">
              Choose how to handle nested objects and arrays in the JSON data
            </div>
          </div>
          <div class="option-group" id="depthLimitGroup" style="display: none">
            <label for="depthLimit">Maximum Flattening Depth</label>
            <select id="depthLimit">
              <option value="1">1 level</option>
              <option value="2" selected>2 levels</option>
              <option value="3">3 levels</option>
              <option value="4">4 levels</option>
              <option value="5">5 levels</option>
            </select>
            <div class="option-description">
              Limit how many levels deep to flatten. Deeper objects will be
              converted to JSON strings.
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel" id="csvPanel">
      <h2 id="csvHeader">CSV Data Preview</h2>
      <div class="panel-content" id="csvContent">
        <div class="info">
          Upload a JSON file to preview its contents and convert to CSV format.
          Supports JSON arrays, single JSON objects, and JSON Lines
          (JSONL/NDJSON) format.
        </div>
        <div class="info" id="columnCount" style="display: none"></div>
        <div class="table-wrapper">
          <div id="tableDisplay" class="empty-state">No data loaded</div>
        </div>
      </div>
    </div>

    <div class="panel" id="outputPanel">
      <h2 id="outputHeader">CSV Output</h2>
      <div class="panel-content" id="outputContent">
        <div class="actions">
          <button class="btn primary" id="downloadBtn" disabled>
            Download CSV
          </button>
          <button class="btn primary" id="copyBtn" disabled>
            Copy to Clipboard
          </button>
        </div>
        <div class="json-output" id="csvOutput">
          <span class="empty-state">No data converted yet</span>
        </div>
      </div>
    </div>

    <script type="module">
      const fileInput = document.getElementById("fileInput");
      const optionsHeader = document.getElementById("optionsHeader");
      const optionsContent = document.getElementById("optionsContent");
      const csvHeader = document.getElementById("csvHeader");
      const csvContent = document.getElementById("csvContent");
      const outputHeader = document.getElementById("outputHeader");
      const outputContent = document.getElementById("outputContent");
      const tableDisplay = document.getElementById("tableDisplay");
      const csvOutput = document.getElementById("csvOutput");
      const downloadBtn = document.getElementById("downloadBtn");
      const copyBtn = document.getElementById("copyBtn");
      const clearBtn = document.getElementById("clearBtn");
      const nestedHandling = document.getElementById("nestedHandling");
      const arrayPath = document.getElementById("arrayPath");
      const arrayPathGroup = document.getElementById("arrayPathGroup");
      const depthLimit = document.getElementById("depthLimit");
      const depthLimitGroup = document.getElementById("depthLimitGroup");
      const columnCount = document.getElementById("columnCount");

      let currentData = null;
      let csvText = null;
      let rawJsonData = null;
      let detectedPaths = [];

      // Toggle collapsible sections
      optionsHeader.addEventListener("click", () => {
        optionsHeader.classList.toggle("collapsed");
        optionsContent.classList.toggle("collapsed");
      });

      csvHeader.addEventListener("click", () => {
        csvHeader.classList.toggle("collapsed");
        csvContent.classList.toggle("collapsed");
      });

      outputHeader.addEventListener("click", () => {
        outputHeader.classList.toggle("collapsed");
        outputContent.classList.toggle("collapsed");
      });

      // Flatten nested objects
      function flattenObject(
        obj,
        prefix = "",
        maxDepth = Infinity,
        currentDepth = 0
      ) {
        const flattened = {};

        for (const key in obj) {
          if (!obj.hasOwnProperty(key)) continue;

          const value = obj[key];
          const newKey = prefix ? `${prefix}.${key}` : key;

          if (value === null || value === undefined) {
            flattened[newKey] = "";
          } else if (
            typeof value === "object" &&
            !Array.isArray(value) &&
            currentDepth < maxDepth
          ) {
            Object.assign(
              flattened,
              flattenObject(value, newKey, maxDepth, currentDepth + 1)
            );
          } else if (Array.isArray(value)) {
            flattened[newKey] = JSON.stringify(value);
          } else if (typeof value === "object") {
            // Max depth reached, stringify the object
            flattened[newKey] = JSON.stringify(value);
          } else {
            flattened[newKey] = value;
          }
        }

        return flattened;
      }

      // Stringify nested objects
      function stringifyNested(obj) {
        const result = {};

        for (const key in obj) {
          if (!obj.hasOwnProperty(key)) continue;

          const value = obj[key];

          if (value === null || value === undefined) {
            result[key] = "";
          } else if (typeof value === "object") {
            result[key] = JSON.stringify(value);
          } else {
            result[key] = value;
          }
        }

        return result;
      }

      // Process JSON data based on nested handling option
      function processJSON(data, handling, maxDepth = Infinity) {
        if (!Array.isArray(data)) {
          data = [data];
        }

        switch (handling) {
          case "flatten":
            return data.map((item) => flattenObject(item));
          case "stringify":
            return data.map((item) => stringifyNested(item));
          case "flattenDepth":
            return data.map((item) => flattenObject(item, "", maxDepth));
          default:
            return data;
        }
      }

      // Convert JSON to CSV
      function jsonToCSV(data) {
        if (!data || data.length === 0) return "";

        // Get all unique keys
        const keys = new Set();
        data.forEach((obj) => {
          Object.keys(obj).forEach((key) => keys.add(key));
        });

        const headers = Array.from(keys);

        // Escape CSV field
        function escapeCSVField(field) {
          if (field === null || field === undefined) return "";

          const str = String(field);

          if (
            str.includes('"') ||
            str.includes(",") ||
            str.includes("\n") ||
            str.includes("\r")
          ) {
            return '"' + str.replace(/"/g, '""') + '"';
          }

          return str;
        }

        // Build CSV
        const csvLines = [];
        csvLines.push(headers.map(escapeCSVField).join(","));

        data.forEach((obj) => {
          const row = headers.map((header) => {
            const value = obj[header];
            return escapeCSVField(value);
          });
          csvLines.push(row.join(","));
        });

        return csvLines.join("\n");
      }

      // Display data as table
      function displayTable(data) {
        if (!data || data.length === 0) {
          tableDisplay.innerHTML =
            '<span class="empty-state">No data in JSON</span>';
          columnCount.style.display = "none";
          return;
        }

        // Get all unique keys
        const keys = new Set();
        data.forEach((obj) => {
          Object.keys(obj).forEach((key) => keys.add(key));
        });

        const headers = Array.from(keys);

        // Update column count indicator
        const rowCount = data.length;
        const colCount = headers.length;
        columnCount.textContent = `${colCount} column${
          colCount !== 1 ? "s" : ""
        } × ${rowCount} row${rowCount !== 1 ? "s" : ""}`;
        columnCount.style.display = "block";

        const table = document.createElement("table");
        table.className = "data-table";

        const thead = document.createElement("thead");
        const headerRow = document.createElement("tr");

        headers.forEach((header) => {
          const th = document.createElement("th");
          th.textContent = header;
          headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement("tbody");

        data.forEach((obj) => {
          const tr = document.createElement("tr");
          headers.forEach((header) => {
            const td = document.createElement("td");
            const value = obj[header];
            td.textContent = value !== null && value !== undefined ? value : "";
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        tableDisplay.innerHTML = "";
        tableDisplay.appendChild(table);
      }

      // Find all arrays in the JSON structure
      function findArrays(obj, path = "") {
        const arrays = [];

        if (Array.isArray(obj)) {
          arrays.push({
            path: path || "(root)",
            data: obj,
            count: obj.length,
          });
        } else if (obj && typeof obj === "object") {
          for (const key in obj) {
            if (!obj.hasOwnProperty(key)) continue;

            const value = obj[key];
            const newPath = path ? `${path}.${key}` : key;

            if (Array.isArray(value)) {
              arrays.push({
                path: newPath,
                data: value,
                count: value.length,
              });
            } else if (value && typeof value === "object") {
              arrays.push(...findArrays(value, newPath));
            }
          }
        }

        return arrays;
      }

      // Get data from selected path
      function getDataFromPath(obj, path) {
        if (path === "(root)") {
          return obj;
        }

        const parts = path.split(".");
        let current = obj;

        for (const part of parts) {
          if (current && typeof current === "object" && part in current) {
            current = current[part];
          } else {
            return null;
          }
        }

        return current;
      }

      // Populate array path selector
      function populateArrayPaths(paths) {
        arrayPath.innerHTML =
          '<option value="">-- Select data array --</option>';

        paths.forEach((pathInfo, index) => {
          const option = document.createElement("option");
          option.value = pathInfo.path;
          option.textContent = `${pathInfo.path} (${pathInfo.count} item${
            pathInfo.count !== 1 ? "s" : ""
          })`;
          arrayPath.appendChild(option);
        });

        // Auto-select if only one array found
        if (paths.length === 1) {
          arrayPath.value = paths[0].path;
        }
      }

      // Convert and display data
      function convertAndDisplay() {
        if (!currentData) return;

        const handling = nestedHandling.value;
        const maxDepth =
          handling === "flattenDepth" ? parseInt(depthLimit.value) : Infinity;
        const processedData = processJSON(currentData, handling, maxDepth);

        displayTable(processedData);
        csvText = jsonToCSV(processedData);
        csvOutput.textContent = csvText;
        downloadBtn.disabled = false;
        copyBtn.disabled = false;

        // Expand panels if collapsed
        csvHeader.classList.remove("collapsed");
        csvContent.classList.remove("collapsed");
        outputHeader.classList.remove("collapsed");
        outputContent.classList.remove("collapsed");
      }

      // Parse JSON Lines format
      function parseJSONLines(text) {
        const lines = text.trim().split("\n");
        const objects = [];

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue; // Skip empty lines

          try {
            const obj = JSON.parse(line);
            objects.push(obj);
          } catch (error) {
            // If parsing fails, it's not JSON Lines format
            return null;
          }
        }

        return objects.length > 0 ? objects : null;
      }

      // Load JSON file
      fileInput.addEventListener("change", () => {
        const file = fileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const text = e.target.result;
            let data;

            // Try parsing as standard JSON first
            try {
              data = JSON.parse(text);
            } catch (jsonError) {
              // If standard JSON parsing fails, try JSON Lines format
              data = parseJSONLines(text);

              if (!data) {
                throw new Error("Invalid JSON format. " + jsonError.message);
              }
            }

            if (!data || (Array.isArray(data) && data.length === 0)) {
              alert("JSON file appears to be empty");
              return;
            }

            rawJsonData = data;

            // Check if data is already an array at root level
            if (Array.isArray(data)) {
              currentData = data;
              arrayPathGroup.style.display = "none";
              convertAndDisplay();
            } else {
              // Find all arrays in the structure
              detectedPaths = findArrays(data);

              if (detectedPaths.length === 0) {
                // No arrays found, treat the object itself as data
                currentData = [data];
                arrayPathGroup.style.display = "none";
                convertAndDisplay();
              } else if (detectedPaths.length === 1) {
                // Only one array found, auto-select it
                currentData = detectedPaths[0].data;
                arrayPathGroup.style.display = "none";
                convertAndDisplay();
              } else {
                // Multiple arrays found, let user choose
                populateArrayPaths(detectedPaths);
                arrayPathGroup.style.display = "block";
                optionsHeader.classList.remove("collapsed");
                optionsContent.classList.remove("collapsed");

                // Don't convert yet, wait for user selection
                tableDisplay.innerHTML =
                  '<span class="empty-state">Please select which data to convert from the dropdown above</span>';
                csvOutput.innerHTML =
                  '<span class="empty-state">No data converted yet</span>';
                downloadBtn.disabled = true;
                copyBtn.disabled = true;
              }
            }
          } catch (error) {
            alert("Error parsing JSON file: " + error.message);
          }
        };

        reader.onerror = () => {
          alert("Error reading file");
        };

        reader.readAsText(file);
      });

      // Handle array path selection
      arrayPath.addEventListener("change", () => {
        const selectedPath = arrayPath.value;

        if (!selectedPath || !rawJsonData) {
          return;
        }

        const selectedData = getDataFromPath(rawJsonData, selectedPath);

        if (selectedData && Array.isArray(selectedData)) {
          currentData = selectedData;
          convertAndDisplay();
        } else {
          alert("Could not retrieve data from selected path");
        }
      });

      // Handle option changes
      nestedHandling.addEventListener("change", () => {
        // Show/hide depth limit option
        if (nestedHandling.value === "flattenDepth") {
          depthLimitGroup.style.display = "block";
        } else {
          depthLimitGroup.style.display = "none";
        }

        if (currentData) {
          convertAndDisplay();
        }
      });

      depthLimit.addEventListener("change", () => {
        if (currentData && nestedHandling.value === "flattenDepth") {
          convertAndDisplay();
        }
      });

      // Copy to clipboard
      copyBtn.addEventListener("click", () => {
        const text = csvOutput.textContent;
        if (!text) return;

        navigator.clipboard
          .writeText(text)
          .then(() => {
            const originalText = copyBtn.textContent;
            copyBtn.textContent = "Copied!";
            setTimeout(() => {
              copyBtn.textContent = originalText;
            }, 2000);
          })
          .catch((err) => {
            alert("Could not copy: " + err);
          });
      });

      // Download CSV
      downloadBtn.addEventListener("click", () => {
        if (!csvText) return;

        const blob = new Blob([csvText], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "converted.csv";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      // Clear all data
      clearBtn.addEventListener("click", () => {
        fileInput.value = "";
        currentData = null;
        csvText = null;
        rawJsonData = null;
        detectedPaths = [];
        arrayPathGroup.style.display = "none";
        arrayPath.innerHTML =
          '<option value="">-- Select data array --</option>';
        tableDisplay.innerHTML =
          '<span class="empty-state">No data loaded</span>';
        csvOutput.innerHTML =
          '<span class="empty-state">No data converted yet</span>';
        columnCount.style.display = "none";
        downloadBtn.disabled = true;
        copyBtn.disabled = true;
      });
    </script>
  </body>
</html>
