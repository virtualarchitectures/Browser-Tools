<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Feature Service Viewer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        margin: 0;
        padding: 20px;
        color: #24292e;
        background: #f6f8fa;
      }
      body.fullscreen {
        padding: 0;
        overflow: hidden;
      }
      h1 {
        margin: 0 0 20px 0;
        font-size: 28px;
        font-weight: 600;
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: flex-start;
        flex-wrap: wrap;
      }
      body.fullscreen .controls {
        display: none;
      }
      .url-input-container {
        flex: 1;
        min-width: 300px;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .url-input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      .url-input:focus {
        outline: none;
        border-color: #0366d6;
        box-shadow: 0 0 0 3px rgba(3, 102, 214, 0.1);
      }
      .url-hint {
        font-size: 12px;
        color: #6b7280;
      }
      .btn {
        background: #0366d6;
        color: #fff;
        padding: 8px 16px;
        border-radius: 6px;
        border: 1px solid rgba(27, 31, 35, 0.15);
        cursor: pointer;
        font-size: 14px;
        line-height: 20px;
        text-decoration: none;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
        white-space: nowrap;
      }
      .btn:hover {
        background: #0256c5;
      }
      .btn.secondary {
        background: #fafbfc;
        color: #24292e;
        border: 1px solid rgba(27, 31, 35, 0.15);
      }
      .btn.secondary:hover {
        background: #f3f4f6;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .panel {
        background: #f6f8fa;
        padding: 16px;
        border-radius: 6px;
        border: 1px solid #e1e4e8;
        margin-bottom: 16px;
      }
      body.fullscreen .panel {
        display: none;
      }
      .map-container {
        background: white;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
        overflow: hidden;
        position: relative;
        margin-bottom: 16px;
      }
      body.fullscreen .map-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: none;
        border-radius: 0;
        z-index: 9999;
      }
      #map {
        width: 100%;
        height: 600px;
        background: #e8e8e8;
      }
      body.fullscreen #map {
        height: 100vh;
      }
      .map-btn {
        position: absolute;
        top: 10px;
        z-index: 1000;
        background: white;
        border: 2px solid rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        padding: 6px 10px;
        cursor: pointer;
        font-size: 18px;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }
      .map-btn:hover {
        background: #f4f4f4;
      }
      .map-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #f4f4f4;
      }
      .fullscreen-btn {
        right: 10px;
      }
      .zoom-extents-btn {
        right: 60px;
      }
      .info {
        font-size: 14px;
        color: #24292e;
        font-weight: 500;
      }
      .status-message {
        padding: 12px;
        border-radius: 6px;
        margin-top: 12px;
        font-size: 14px;
      }
      .status-message.loading {
        background: #dbeafe;
        color: #1e40af;
        border: 1px solid #93c5fd;
      }
      .status-message.error {
        background: #fee2e2;
        color: #991b1b;
        border: 1px solid #fca5a5;
      }
      .status-message.success {
        background: #d1fae5;
        color: #065f46;
        border: 1px solid #6ee7b7;
      }
      .back-link {
        display: inline-block;
        color: #0366d6;
        text-decoration: none;
        margin-bottom: 20px;
        font-size: 14px;
      }
      .back-link:hover {
        text-decoration: underline;
      }
      h2 {
        font-size: 18px;
        font-weight: 600;
        margin-top: 0;
        margin-bottom: 15px;
      }
      h3 {
        background: #0366d6;
        color: white;
        padding: 12px 15px;
        cursor: pointer;
        user-select: none;
        display: flex;
        align-items: center;
        font-size: 16px;
        font-weight: 600;
        margin-top: 0;
        margin-bottom: 0;
        border-radius: 4px 4px 0 0;
      }
      h3:hover {
        background: #0256c5;
      }
      h3::before {
        content: "▼";
        margin-right: 8px;
        font-size: 12px;
        transition: transform 0.2s;
      }
      h3.collapsed::before {
        transform: rotate(-90deg);
      }
      .empty-state {
        text-align: center;
        color: #586069;
        padding: 40px 20px;
        font-size: 14px;
      }
      .feature-type-section {
        margin-bottom: 30px;
        border: 1px solid #ddd;
        border-radius: 4px;
        overflow: hidden;
      }
      .table-content {
        max-height: 500px;
        transition: max-height 0.3s ease;
        overflow: auto;
      }
      .table-content.collapsed {
        max-height: 0;
        overflow: hidden;
      }
      .properties-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 0;
        font-size: 14px;
      }
      .properties-table th {
        background: #f6f8fa;
        font-weight: 600;
        color: #24292e;
        text-align: left;
        padding: 10px 12px;
        border: 1px solid #e1e4e8;
      }
      .properties-table td {
        padding: 8px 12px;
        border: 1px solid #e1e4e8;
        color: #24292e;
      }
      .properties-table tr:hover {
        background: #f6f8fa;
        cursor: pointer;
      }
      .properties-table tr.selected {
        background: #ddf4ff;
      }
      .layer-selector {
        margin-top: 12px;
        padding: 12px;
        background: white;
        border: 1px solid #e1e4e8;
        border-radius: 6px;
      }
      .layer-selector label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        font-size: 14px;
      }
      .layer-selector select {
        width: 100%;
        padding: 8px;
        border: 1px solid #d1d5db;
        border-radius: 6px;
        font-size: 14px;
        font-family: Helvetica, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Arial, sans-serif;
      }

      .loading-spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid #93c5fd;
        border-top-color: #1e40af;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-right: 8px;
        vertical-align: middle;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <a href="index.html" class="back-link">← Back to Browser Tools</a>

    <h1>Feature Service Viewer</h1>

    <div class="panel">
      <div class="controls">
        <div class="url-input-container">
          <input
            type="text"
            id="urlInput"
            class="url-input"
            placeholder="Enter ArcGIS Feature Service URL..."
          />
          <div class="url-hint">
            Enter the base URL of an ArcGIS Feature Service (FeatureServer or
            MapServer)
          </div>
        </div>
        <button class="btn" id="loadBtn">Load</button>
        <button class="btn secondary" id="clearBtn" disabled>Clear</button>
      </div>
      <div id="layerSelector" class="layer-selector" style="display: none">
        <label for="layerSelect">Select Layer:</label>
        <select id="layerSelect"></select>
      </div>
      <div id="statusMessage"></div>
    </div>

    <div class="map-container">
      <button
        class="map-btn zoom-extents-btn"
        id="zoomExtentsBtn"
        title="Zoom to Extents"
        disabled
      >
        ⌖
      </button>
      <button
        class="map-btn fullscreen-btn"
        id="fullscreenBtn"
        title="Toggle fullscreen"
      >
        ⛶
      </button>
      <div id="map"></div>
    </div>

    <div class="panel" id="propertiesPanel">
      <h2>Feature Properties</h2>
      <div id="propertiesDisplay" class="empty-state">
        No data loaded. Enter a Feature Service URL and click Load.
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
      /* =========================
         DOM Elements
         ========================= */
      const urlInput = document.getElementById("urlInput");
      const loadBtn = document.getElementById("loadBtn");
      const clearBtn = document.getElementById("clearBtn");
      const zoomExtentsBtn = document.getElementById("zoomExtentsBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const propertiesPanel = document.getElementById("propertiesPanel");
      const propertiesDisplay = document.getElementById("propertiesDisplay");
      const statusMessage = document.getElementById("statusMessage");
      const layerSelector = document.getElementById("layerSelector");
      const layerSelect = document.getElementById("layerSelect");

      /* =========================
         State Variables
         ========================= */
      let geojsonLayer = null;
      let currentGeoJSON = null;
      let allFeatures = [];
      let currentServiceUrl = null;
      let availableLayers = [];

      /* =========================
         Initialize Map
         ========================= */
      const map = L.map("map").setView([0, 0], 2);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19,
      }).addTo(map);

      /* =========================
         Utility Functions
         ========================= */

      function showStatus(message, type) {
        statusMessage.innerHTML = message;
        statusMessage.className = `status-message ${type}`;
        statusMessage.style.display = "block";
      }

      function hideStatus() {
        statusMessage.style.display = "none";
        statusMessage.innerHTML = "";
      }

      function normalizeUrl(url) {
        // Remove trailing slash
        url = url.trim().replace(/\/$/, "");

        // If URL doesn't end with a number (layer ID), it's the base service URL
        return url;
      }

      async function fetchServiceInfo(serviceUrl) {
        try {
          return await arcgisPost(serviceUrl, { f: "json" });
        } catch (error) {
          throw new Error(`Failed to fetch service info: ${error.message}`);
        }
      }

      async function arcgisPost(url, params) {
        const response = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams(params),
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.error) throw new Error(data.error.message);
        return data;
      }

      async function fetchLayerCount(layerUrl) {
        const data = await arcgisPost(`${layerUrl}/query`, {
          where: "1=1",
          returnCountOnly: "true",
          f: "json",
        });
        return data.count;
      }

      async function fetchBatch(layerUrl, offset, batchSize) {
        const data = await arcgisPost(`${layerUrl}/query`, {
          where: "1=1",
          outFields: "*",
          returnGeometry: "true",
          outSR: "4326",
          f: "json",
          resultRecordCount: batchSize.toString(),
          resultOffset: offset.toString(),
        });
        return esriToGeoJSON(data);
      }

      function esriToGeoJSON(esriData) {
        const features = (esriData.features || []).map((f) => ({
          type: "Feature",
          properties: f.attributes || {},
          geometry: esriGeometryToGeoJSON(f.geometry, esriData.geometryType),
        }));
        return {
          type: "FeatureCollection",
          features,
          exceededTransferLimit: esriData.exceededTransferLimit,
        };
      }

      function esriGeometryToGeoJSON(geom, geometryType) {
        if (!geom) return null;
        switch (geometryType) {
          case "esriGeometryPoint":
            return { type: "Point", coordinates: [geom.x, geom.y] };
          case "esriGeometryMultipoint":
            return { type: "MultiPoint", coordinates: geom.points };
          case "esriGeometryPolyline":
            return geom.paths.length === 1
              ? { type: "LineString", coordinates: geom.paths[0] }
              : { type: "MultiLineString", coordinates: geom.paths };
          case "esriGeometryPolygon": {
            // Signed area: negative = clockwise = outer ring in Esri convention
            const signedArea = (ring) => {
              let s = 0;
              for (let i = 0; i < ring.length - 1; i++)
                s += ring[i][0] * ring[i + 1][1] - ring[i + 1][0] * ring[i][1];
              return s;
            };
            const outer = geom.rings.filter((r) => signedArea(r) <= 0);
            const holes = geom.rings.filter((r) => signedArea(r) > 0);
            if (outer.length <= 1) {
              return {
                type: "Polygon",
                coordinates: [outer[0] || geom.rings[0], ...holes],
              };
            }
            // Multi-part polygon: assign holes to first outer ring (simplified)
            return {
              type: "MultiPolygon",
              coordinates: outer.map((ring, i) =>
                i === 0 ? [ring, ...holes] : [ring]
              ),
            };
          }
          default:
            return null;
        }
      }

      function getFeatureColor(feature) {
        if (feature && feature.properties) {
          for (const key in feature.properties) {
            if (
              key.toLowerCase() === "color" ||
              key.toLowerCase() === "colour"
            ) {
              const color = feature.properties[key];
              if (color && typeof color === "string") {
                return color;
              }
            }
          }
        }
        return "#0366d6";
      }

      /* =========================
         Main Functions
         ========================= */

      async function loadService() {
        const url = urlInput.value.trim();
        if (!url) {
          showStatus("Please enter a Feature Service URL", "error");
          return;
        }

        const serviceUrl = normalizeUrl(url);
        currentServiceUrl = serviceUrl;

        showStatus(
          '<span class="loading-spinner"></span>Loading service information...',
          "loading"
        );

        try {
          const serviceInfo = await fetchServiceInfo(serviceUrl);

          // Check if this is a single layer or a service with multiple layers
          if (serviceInfo.layers && serviceInfo.layers.length > 0) {
            // Multiple layers available
            availableLayers = serviceInfo.layers;
            displayLayerSelector(availableLayers);
            showStatus(
              `Service loaded: ${
                serviceInfo.name || "Unnamed Service"
              }. Select a layer to view.`,
              "success"
            );
          } else if (serviceInfo.type === "Feature Layer") {
            // Single layer - load it directly
            await loadLayer(serviceUrl);
          } else {
            // Try to load as layer 0
            await loadLayer(`${serviceUrl}/0`);
          }
        } catch (error) {
          showStatus(`Error: ${error.message}`, "error");
          console.error("Error loading service:", error);
        }
      }

      function displayLayerSelector(layers) {
        layerSelect.innerHTML = "";

        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "-- Select a layer --";
        layerSelect.appendChild(defaultOption);

        layers.forEach((layer) => {
          const option = document.createElement("option");
          option.value = layer.id;
          option.textContent = `${layer.name} (ID: ${layer.id})`;
          layerSelect.appendChild(option);
        });

        layerSelector.style.display = "block";
      }

      async function loadLayer(layerUrl) {
        loadBtn.disabled = true;
        showStatus(
          '<span class="loading-spinner"></span>Getting feature count...',
          "loading"
        );

        initGeojsonLayer();

        let total = null;
        try {
          total = await fetchLayerCount(layerUrl);
        } catch (e) {
          // Count query not supported by this service, proceed without total
        }

        const batchSize = 1000;
        let offset = 0;
        let loadedCount = 0;
        const geojsonFeatures = [];
        let firstBatch = true;

        try {
          while (true) {
            const countText =
              total !== null ? `${loadedCount} of ${total}` : `${loadedCount}`;
            showStatus(
              `<span class="loading-spinner"></span>Loading features... (${countText})`,
              "loading"
            );

            const batch = await fetchBatch(layerUrl, offset, batchSize);

            if (!batch.features || batch.features.length === 0) {
              if (offset === 0) {
                showStatus("No features found in this layer", "error");
                return;
              }
              break;
            }

            geojsonFeatures.push(...batch.features);
            geojsonLayer.addData(batch);
            loadedCount += batch.features.length;

            // Fit map to first batch
            if (firstBatch && geojsonLayer.getBounds().isValid()) {
              map.fitBounds(geojsonLayer.getBounds());
              firstBatch = false;
            }

            offset += batchSize;

            // Stop when the service reports no more records
            if (!batch.exceededTransferLimit) break;
            // Fallback: stop if we received fewer records than requested
            if (batch.features.length < batchSize) break;
            // Stop if we've loaded everything we know about
            if (total !== null && loadedCount >= total) break;
          }

          currentGeoJSON = { type: "FeatureCollection", features: geojsonFeatures };
          displayProperties(currentGeoJSON);

          clearBtn.disabled = false;
          zoomExtentsBtn.disabled = false;

          showStatus(`Successfully loaded ${loadedCount} features`, "success");
          setTimeout(() => {
            hideStatus();
          }, 3000);
        } catch (error) {
          showStatus(`Error: ${error.message}`, "error");
          console.error("Error loading layer:", error);
        } finally {
          loadBtn.disabled = false;
        }
      }

      function initGeojsonLayer() {
        if (geojsonLayer) {
          map.removeLayer(geojsonLayer);
        }

        allFeatures = [];

        geojsonLayer = L.geoJSON(null, {
          style: function (feature) {
            const featureColor = getFeatureColor(feature);
            return {
              color: featureColor,
              weight: 2,
              opacity: 0.8,
              fillOpacity: 0.3,
            };
          },
          pointToLayer: function (feature, latlng) {
            const featureColor = getFeatureColor(feature);
            return L.circleMarker(latlng, {
              radius: 6,
              fillColor: featureColor,
              color: "#fff",
              weight: 2,
              opacity: 1,
              fillOpacity: 0.8,
            });
          },
          onEachFeature: function (feature, layer) {
            allFeatures.push({ feature, layer });

            layer.on("click", function () {
              highlightFeature(feature, layer);
            });

            if (feature.properties) {
              let popupContent = "<strong>Properties:</strong><br>";
              for (const [key, value] of Object.entries(feature.properties)) {
                if (value !== null && value !== undefined) {
                  popupContent += `<strong>${key}:</strong> ${value}<br>`;
                }
              }
              layer.bindPopup(popupContent);
            }
          },
        }).addTo(map);
      }

      function highlightFeature(feature, layer) {
        // Reset all styles
        if (geojsonLayer) {
          geojsonLayer.eachLayer(function (l) {
            geojsonLayer.resetStyle(l);
          });
        }

        // Remove selected class from all rows
        document.querySelectorAll(".properties-table tr").forEach((row) => {
          row.classList.remove("selected");
        });

        // Highlight selected feature
        if (layer.setStyle) {
          layer.setStyle({
            color: "#d73a49",
            weight: 3,
            fillOpacity: 0.5,
          });
        }

        // Find and highlight the corresponding row
        allFeatures.forEach((item, index) => {
          if (item.feature === feature) {
            const row = document.querySelector(
              `tr[data-feature-index="${index}"]`
            );
            if (row) {
              row.classList.add("selected");
              row.scrollIntoView({
                behavior: "smooth",
                block: "nearest",
              });
            }
          }
        });
      }

      function displayProperties(geojson) {
        propertiesDisplay.innerHTML = "";

        if (!geojson.features || geojson.features.length === 0) {
          propertiesDisplay.innerHTML =
            '<div class="empty-state">No features found</div>';
          return;
        }

        // Group features by geometry type
        const featuresByType = {};
        geojson.features.forEach((feature, index) => {
          const type = feature.geometry ? feature.geometry.type : "Unknown";
          if (!featuresByType[type]) {
            featuresByType[type] = [];
          }
          featuresByType[type].push({ feature, index });
        });

        // Create a table for each geometry type
        Object.keys(featuresByType)
          .sort()
          .forEach((type) => {
            const section = document.createElement("div");
            section.className = "feature-type-section";

            const heading = document.createElement("h3");
            heading.textContent = `${type} (${featuresByType[type].length})`;

            section.appendChild(heading);

            const tableContent = document.createElement("div");
            tableContent.className = "table-content";

            heading.addEventListener("click", () => {
              tableContent.classList.toggle("collapsed");
              heading.classList.toggle("collapsed");
            });

            const features = featuresByType[type];

            // Get all unique property keys
            const propertyKeys = new Set();
            features.forEach(({ feature }) => {
              if (feature.properties) {
                Object.keys(feature.properties).forEach((key) =>
                  propertyKeys.add(key)
                );
              }
            });

            // Sort keys, with common ID fields first
            let sortedKeys = Array.from(propertyKeys).sort();
            const priorityKeys = [
              "OBJECTID",
              "FID",
              "ID",
              "id",
              "objectid",
              "fid",
            ];
            priorityKeys.forEach((priorityKey) => {
              const index = sortedKeys.indexOf(priorityKey);
              if (index > -1) {
                sortedKeys.splice(index, 1);
                sortedKeys.unshift(priorityKey);
              }
            });

            // Create table
            const table = document.createElement("table");
            table.className = "properties-table";

            // Create header row
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");

            sortedKeys.forEach((key) => {
              const th = document.createElement("th");
              th.textContent = key;
              headerRow.appendChild(th);
            });

            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Create data rows
            const tbody = document.createElement("tbody");
            features.forEach(({ feature, index }) => {
              const row = document.createElement("tr");
              row.dataset.featureIndex = index;

              sortedKeys.forEach((key) => {
                const td = document.createElement("td");
                const value = feature.properties && feature.properties[key];

                if (value !== undefined && value !== null) {
                  td.textContent =
                    typeof value === "object" ? JSON.stringify(value) : value;
                } else {
                  td.textContent = "";
                  td.style.background = "#fafbfc";
                }

                row.appendChild(td);
              });

              // Add click handler to row
              row.addEventListener("click", () => {
                const item = allFeatures[index];
                if (item) {
                  const { feature, layer } = item;

                  // Zoom to feature
                  if (layer.getBounds) {
                    map.fitBounds(layer.getBounds());
                  } else if (layer.getLatLng) {
                    map.setView(layer.getLatLng(), 15);
                  }

                  highlightFeature(feature, layer);

                  // Open popup
                  if (layer.openPopup) {
                    layer.openPopup();
                  }
                }
              });

              tbody.appendChild(row);
            });

            table.appendChild(tbody);
            tableContent.appendChild(table);
            section.appendChild(tableContent);
            propertiesDisplay.appendChild(section);
          });
      }

      function clearMap() {
        if (geojsonLayer) {
          map.removeLayer(geojsonLayer);
          geojsonLayer = null;
        }
        currentGeoJSON = null;
        allFeatures = [];
        currentServiceUrl = null;
        availableLayers = [];
        clearBtn.disabled = true;
        zoomExtentsBtn.disabled = true;
        layerSelector.style.display = "none";
        propertiesDisplay.innerHTML =
          '<div class="empty-state">No data loaded. Enter a Feature Service URL and click Load.</div>';
        hideStatus();
        map.setView([0, 0], 2);
      }

      /* =========================
         Event Handlers
         ========================= */

      loadBtn.addEventListener("click", loadService);

      urlInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          loadService();
        }
      });

      layerSelect.addEventListener("change", async (e) => {
        const layerId = e.target.value;
        if (layerId && currentServiceUrl) {
          await loadLayer(`${currentServiceUrl}/${layerId}`);
        }
      });

      clearBtn.addEventListener("click", clearMap);

      zoomExtentsBtn.addEventListener("click", () => {
        if (geojsonLayer && geojsonLayer.getBounds().isValid()) {
          map.fitBounds(geojsonLayer.getBounds());
        }
      });

      fullscreenBtn.addEventListener("click", () => {
        document.body.classList.toggle("fullscreen");

        if (document.body.classList.contains("fullscreen")) {
          fullscreenBtn.textContent = "⛶";
          fullscreenBtn.title = "Exit fullscreen";
        } else {
          fullscreenBtn.textContent = "⛶";
          fullscreenBtn.title = "Toggle fullscreen";
        }

        setTimeout(() => {
          map.invalidateSize();
        }, 100);
      });

      document.addEventListener("keydown", (e) => {
        if (
          e.key === "Escape" &&
          document.body.classList.contains("fullscreen")
        ) {
          fullscreenBtn.click();
        }
      });
    </script>
  </body>
</html>
